```
2020本科OS课

2020研究生AOS课
https://next.xuetangx.com/course/thu080917777/3234209?fromArray=search_result

实验 （ucore）
https://1790865014.gitbook.io/ucore-step-by-step/

实验（rcore）
https://os20-rcore-tutorial.github.io/rCore-Tutorial-deploy/

第一节
Q1：应用程序能直接调用内核的函数吗？说明原因，举个例子。
[陈兴init]  。。。。
[应雯婧] 不能，为了安全，需要通过系统调用

[陈兴1]  一般意义上应该是不能、感觉原因在于目前有区分用户态合内核态、这个能不能的关键在于权限的赋予、实现上目前区分了内核代码和用户代码的存放空间、那么从用户空间放到cpu去执行的命令、检查其权限访问不到内核空间的位置就不可以了、那么怎么才可以访问呢、那需要中断指令、应该是不同CPU架构自带的指令、你只要执行这个命令CPU就执行固定的操作、这样我在用户态执行下中断指令、跑去CPU执行固定操作、我希望这个固定操作做的是跳转到一个地址、刚好这个地址设置为内核地址空间里的地址、这样我执行的程序就是内核态的程序了、因为CPU一看其来自内核空间、其权限也可以执行、所以权限这个东西是人为设计的、为了各种好处、
举个🌰、用户在调用syscall时、这个函数里应该会执行一个中断命令、让CPU跳转到中断函数列表的开始地址、根据寄存器里的中断号、执行中断、而恰好这个中断函数是syscall分发函数、又根据寄存器里syscall的号、调用syscall函数、完成用户调用内核、同时这种设计方式就像前后台、通过api调用、也只有这一种方式可进入内核（在不考虑漏洞的情况下）、调用规定好可被调用的程序、

[cx]:不能、为了内核安全、
举例：用户程序在内核代码处修改造成瘫痪、
Q2：内核能直接调用应用程序的函数吗？说明原因，举个例子。
[陈兴1] 同理、问题出现在权限设计上、如果内核的权限设计本就可以访问用户空间、那么理论上可以执行、但用户程序实际上不是固定的、可能先有一步要指定好执行什么程序的过程、然后去执行、没有想出来有什么🌰、但是执行的话、是不是应该对这执行函数赋予高级的权限、否则好像很难能返回回来、需要具体到设计与实现、才能确定、
[应雯婧] 应该不能，动态模块加载在内核通过 usermode-helper 进程进行。

[cx] 不能、用户程序不可信、没遇到这样的例子
Q3：请说出你知道的特权指令或特权寄存器（x86/arm/mips/risc-v）
[陈兴] 学时候偷懒、用的时候百度、都没怎么有印象、只能记起最简单的x86_64 设置cr3、关中断、开中断、risc-v、类似也有名字忘记了、复习后回来补上、
[应雯婧] 清内存、置时钟、分配系统资源、修改虚拟内存的段表和页表都是特权指令，特权寄存器只记得GDTR
Q4: 除了基于页表的地址空间隔离，请问还能想到其他的地址空间隔离方式吗？
[陈兴] 地址的隔离方法、只要做一层抽象、限制住范围、就可以形成一次隔离、比如我们能操作的实际空间只有内存那么大、而目前os使用、就是全都划到自己控制范围下、是因为bootloader毫无保留给到os内存布局信息、那么我在os上在做一层抽象、控制着给到os内存布局范围、那么这个os1就只能支配到这个范围的内容、我再启动个别的os2、就与那个os1、隔离了、os都隔离了、os里的一切也都隔离了、内核与用户也是这样隔离、本是一个地址空间、做一层抽象、形成用户与内核、限制其范围与权限逻辑、页表也是由一个大空间、一层层划分出来、形成隔离、这是比较native想法、如果有更高明隔离、可能需要用点时间思考下、但是隔离是有代价的、只要有隔离、就要考虑沟通问题、怎么沟通、沟通成本、也是一大块需要设计的东西、
[应雯婧] 我只学过基于页表的地址空间隔离，如果不用页表，可以单纯地使用分段？
在网上看到一个实现不同CPU核间的内核空间隔离的方法（https://patents.google.com/patent/CN101477477A/zh），我认为有一些参考价值，未来的electronic device肯定会增加CPU核的数量，当运行在CPU 核上的内核态业务请求物理空间时，在该CPU核的虚拟空间中的非公共系统 空间部分分配该CPU核的私有虚拟空间，其中，所述CPU核的虛拟空间与其他CPU核的虚拟空间相互独 立

[cx] 分段、hypervisor
Q5：中断/异常有何区别？如果没有中断机制，应用程序/操作系统要如何与外设进行交互？
[陈兴1] 中断/异常的来源是在区分 对响应类别的区分、把自己看成独立一体的系统、外部世界对你的影响全是中断、自己肚子疼、腿疼、脚疼、手疼、脑袋疼、就是异常、如果没了中断机制、就好像把自己关在小黑屋、基本接收不到任何信息、这时候要与外面交互、就需要自己、费点劲主动去问、问问发什么事啊、怎么样了啊、能不能给我帮帮忙啊、简称轮询、(；′⌒`)
[应雯婧] 异常当前指令失败后的处理请求（同步），中断是来自硬件设备的处理请求（异步），中断是为了提高和外界交互的效率，如果没有中断，或许可以直接杀死程序，或者等应用程序执行完毕再交互？
Q6：在计算机系统中实现隔离的方法有哪几种？
[陈兴1] 实现 隔离方式 ...um对隔离不太清楚其指代什么意思、猜测 使用页表实现地址隔离？基于页表、使用进程线程实现 程序隔离？、基于 地址和权限设置、实现内核与用户隔离？基于hypervisor实现os的隔离？待确认！
[应雯婧] 补充一个使用虚拟地址空间实现的进程隔离？
Q7：隔离的角度看，操作系统中的用户态和内核态有什么区别？
[陈兴1] 从隔离角度看、隔离把功能分层、内核态和用户态主要运行的程序目的不同、形成良好的上下层结构、内核为用户提供服务、类似单体后台、
第二节
Q1：你是如何理解和描述OS与APP的交互接口？
[陈兴1] 类似市面上最普及的前后台、os是server 、app是client、通过规定好的接口(比如RESTful接口)也可以叫api？沟通信息、不过os里把这个叫做syscall、作用一样、也是规定好可以沟通的事情、提供app来调用
[应雯婧] 就是系统调用？调用内核提供的接口进入内核态，使用相关函数获取资源。每一个进程都有user stack和kernel stack，需要进行系统调用的时候进入内核态，在该进程的kernel stack执行
Q2：你是如何理解和描述OS与CPU的交互接口？
[陈兴1] 这个好像有点不太一样、因为os 与 app 交互 both are 程序、os 与 CPU 交互 os是个程序、但cpu可是固定的逻辑电路、不是想轻易改就能改的、还很抽象、因为电路实现、只能通过手册把他提供的内容找到、来使用、形成叫做ABI的接口、os对照着进行调用、获取CPU的功能
Q3：我们理解的RISC-V的Supervisor特权模式适合运行哪种类型的软件？
[陈兴1] supervisor 适合 运行 调用 cpu接口软件、比如内核、是需要可靠的、防止崩溃的软件、因为、比如 一个公司 CEO不可靠、公司很有可能就要倒闭了、
Q4: 如果让一个通用操作系统（如Linux）运行在RISC-V的User模式，请问会发生什么现象？是否有相应的解决方法？
[陈兴1] 目前还无法完全理解 linux怎么运行在用户态、范围理解不清晰、比如linux内核里需要执行cpu的操作、不就全都无法执行了么、那不就crash了么、感觉bootloader都过不去啊、难到要在底下在架一层os、为这个linux提供服务？成为VMM？那还要给这两层增加一层交互、类似syscall、linux代码不能改、这层"syscall"名字也被固定了？也还需要cpu支持吧、想不清楚、
Q5：RISC-V的中断产生后，CPU首先会在哪种特权模式下运行？
[陈兴1] 盲猜 M 、学习不到位、都忽略了、不确定、待之后再次学习riscv去确定
Q6：RISC-V有哪几个特权级？
[陈兴1] 4 [MS(R)U]、带上hypervisor 觉得可以这么写[MHSU] 抱歉以上是猜测、不过我找到原文来描述了 
The previous Hypervisor mode (H-mode) designed to support Type-1 hypervisors has been removed and the encoding space reserved as we are focusing on hypervisor support via an extended 4 Volume II: RISC-V Privileged Architectures V1.10 S mode suitable for both Type-1 and Type-2 hypervisors as described in Chapter 5. The encoding space for H is reserved for future use and to avoid backwards incompatible changes in bit positions in various status regusters. The bit positions might be reused in the future for different Type-1 hypervisor support or possibly additional secure execution modes. 
意思大概是为了适配、不规定那么死、留待自己扩展？
第三节 
Q1：在你熟悉的操作系统上用你熟悉的语言写一个跟踪功能函数，可以获取当前的函数调用栈和函数调用参数信息。

Q2：高级语言的编译到机器指令的调用约定都约定什么内容？


第四节
Q1：根据课程介绍，安装qemu-4.1+，通过qemu的monitor，查看ROM的指令是哪些？
A： 安装 Qemu: https://rcore-os.github.io/rCore_tutorial_doc/chapter2/part5.html
```